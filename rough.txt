In SQL Server, there are several built-in stored procedures and system views that are commonly used for tasks related to database management, metadata retrieval, and troubleshooting. Here’s a list of some of the most frequently used ones:

---

### Commonly Used Built-In Stored Procedures

1. **sp_help**  
   - Provides details about an object, such as a table, view, or stored procedure.
   - Usage: `EXEC sp_help 'TableName'`

2. **sp_who** and **sp_who2**  
   - Displays information about current users, sessions, and processes.
   - Usage: `EXEC sp_who` or `EXEC sp_who2`

3. **sp_lock**  
   - Shows information about locks currently held by active processes.
   - Usage: `EXEC sp_lock`

4. **sp_executesql**  
   - Executes dynamic SQL and is often used for parameterized queries.
   - Usage: `EXEC sp_executesql N'SELECT * FROM TableName WHERE Column = @Param', N'@Param INT', @Param = 10`

5. **sp_rename**  
   - Renames a database object, such as a table or column.
   - Usage: `EXEC sp_rename 'OldName', 'NewName'`

6. **sp_adduser** and **sp_addlogin**  
   - Creates a new user or login in the SQL Server instance.
   - Usage: `EXEC sp_adduser 'username'`

7. **sp_helpindex**  
   - Lists all indexes on a specified table.
   - Usage: `EXEC sp_helpindex 'TableName'`

8. **sp_helpconstraint**  
   - Shows constraints (like primary key, foreign key) on a specified table.
   - Usage: `EXEC sp_helpconstraint 'TableName'`

9. **sp_configure**  
   - Configures server-level settings.
   - Usage: `EXEC sp_configure 'setting_name', value`

10. **sp_tables**  
    - Provides a list of all tables and views in the current database.
    - Usage: `EXEC sp_tables`

---

### Commonly Used System Views

1. **sys.tables**  
   - Contains a row for each table object in the database.
   - Usage: `SELECT * FROM sys.tables`

2. **sys.columns**  
   - Lists all columns for tables and views within the database.
   - Usage: `SELECT * FROM sys.columns`

3. **sys.indexes**  
   - Provides information about indexes on tables and views.
   - Usage: `SELECT * FROM sys.indexes`

4. **sys.objects**  
   - Contains a row for each object (tables, views, procedures, etc.) in the database.
   - Usage: `SELECT * FROM sys.objects`

5. **sys.procedures**  
   - Contains information about all stored procedures in the database.
   - Usage: `SELECT * FROM sys.procedures`

6. **sys.dm_exec_sessions**  
   - Provides session-level information for active connections.
   - Usage: `SELECT * FROM sys.dm_exec_sessions`

7. **sys.dm_exec_requests**  
   - Displays information about each request currently being executed.
   - Usage: `SELECT * FROM sys.dm_exec_requests`

8. **sys.dm_exec_query_stats**  
   - Contains aggregate performance statistics for cached query plans.
   - Usage: `SELECT * FROM sys.dm_exec_query_stats`

9. **sys.dm_tran_locks**  
   - Provides details about active locks and transactions.
   - Usage: `SELECT * FROM sys.dm_tran_locks`

10. **information_schema.tables**  
    - Standardized view that shows table metadata.
    - Usage: `SELECT * FROM information_schema.tables`

---

These stored procedures and views are commonly used for database management, querying metadata, analyzing performance, and managing user sessions.

-----------------------------------------------------------------------------------------------------------------------------

### 1. **Use of `STRING_SPLIT` in SQL Server**

`STRING_SPLIT` is a function in SQL Server that splits a string into rows based on a specified delimiter. It’s especially helpful when you have a comma-separated string and want to convert it into rows.

#### Example:
Suppose you have a string of comma-separated values and want to get each value on a new row.

```sql
DECLARE @Colors NVARCHAR(100) = 'Red,Green,Blue,Yellow'

SELECT value AS Color
FROM STRING_SPLIT(@Colors, ',')
```

**Output:**
| Color   |
|---------|
| Red     |
| Green   |
| Blue    |
| Yellow  |

In this example, `STRING_SPLIT` takes the `@Colors` string and splits it based on the comma delimiter, returning each color as a separate row.

---

### 2. **Simple Example of a Correlated Subquery**

A **correlated subquery** is a subquery that refers to a column from the outer query. The subquery is executed once for each row processed by the outer query.

#### Example:
Consider two tables: `Employees` and `Departments`.

- `Employees` table:
  | EmployeeID | EmployeeName | DepartmentID |
  |------------|--------------|--------------|
  | 1          | John         | 1            |
  | 2          | Jane         | 2            |
  | 3          | Mike         | 1            |
  | 4          | Sara         | 3            |

- `Departments` table:
  | DepartmentID | DepartmentName |
  |--------------|----------------|
  | 1            | Sales          |
  | 2            | Marketing      |
  | 3            | IT             |

Suppose you want to find employees whose department has more than one employee.

Here’s how you can use a correlated subquery:

```sql
SELECT EmployeeName
FROM Employees e1
WHERE (SELECT COUNT(*)
       FROM Employees e2
       WHERE e2.DepartmentID = e1.DepartmentID) > 1
```

**Explanation:**
- The outer query (`SELECT EmployeeName FROM Employees e1`) retrieves each employee.
- The correlated subquery `(SELECT COUNT(*) FROM Employees e2 WHERE e2.DepartmentID = e1.DepartmentID)` calculates the number of employees in the same department as the current employee (`e1`).
- If the count is greater than 1, the employee is selected in the result.

**Output:**
| EmployeeName |
|--------------|
| John         |
| Mike         |

In this case, `John` and `Mike` are both in the `Sales` department, which has more than one employee, so they are included in the output.

------------------------------------------------------------------------------------------------------------------------------

DECLARE @counter INT = 1;

WHILE @counter <= 5000
BEGIN
    INSERT INTO Employees (EmployeeName, Salary, DepartmentID)
    VALUES (
        CONCAT('Employee', @counter),              -- EmployeeName
        5000 + (RAND() * 5000),                    -- Random Salary between 5000 and 10000
        1 + (ABS(CHECKSUM(NEWID())) % 3)           -- Random DepartmentID (1, 2, or 3)
    );
    SET @counter = @counter + 1;
END;


---------------------------------------------------------------------------------------------------------------------

Correlated subqueries in SQL are subqueries that depend on values from the outer query, which makes them unique because they are evaluated once for each row processed by the outer query. In a correlated subquery, the inner query references a column from the outer query, so it "correlates" with each row processed by the outer query. Let’s break down this concept and look at how it works, with examples.

### Key Characteristics of Correlated Subqueries

1. **Dependency on Outer Query**: The inner (subquery) part of a correlated subquery cannot run independently of the outer query because it refers to columns from the outer query.
2. **Row-by-Row Execution**: The inner query is re-evaluated for each row that the outer query processes, which can sometimes lead to performance considerations, especially with large datasets.
3. **Filtering or Aggregation Context**: Correlated subqueries are often used when you need to compare each row in a table with rows in the same table or another table, especially for tasks like finding matches, filtering, or aggregate values that vary for each row.

### Example Scenario

Let’s use the following tables as an example:

- **Employees**:
  | EmployeeID | EmployeeName | Salary | DepartmentID |
  |------------|--------------|--------|--------------|
  | 1          | John         | 5000   | 1            |
  | 2          | Jane         | 7000   | 2            |
  | 3          | Mike         | 6000   | 1            |
  | 4          | Sara         | 9000   | 2            |
  | 5          | Chris        | 5500   | 1            |

- **Departments**:
  | DepartmentID | DepartmentName |
  |--------------|----------------|
  | 1            | Sales          |
  | 2            | Marketing      |

#### Example 1: Finding Employees with the Highest Salary in Each Department

Suppose you want to list the employees who have the highest salary within their respective departments. To achieve this, a correlated subquery can be used.

```sql
SELECT EmployeeName, Salary, DepartmentID
FROM Employees e1
WHERE Salary = (
    SELECT MAX(Salary)
    FROM Employees e2
    WHERE e2.DepartmentID = e1.DepartmentID
);
```

#### Explanation of the Query

1. **Outer Query**: `SELECT EmployeeName, Salary, DepartmentID FROM Employees e1` – this selects the columns from the `Employees` table. Here, `e1` is an alias for `Employees`, allowing us to differentiate between the outer query and the subquery.
2. **Correlated Subquery**: 
   - `(SELECT MAX(Salary) FROM Employees e2 WHERE e2.DepartmentID = e1.DepartmentID)`: The subquery finds the maximum salary in each department.
   - **Correlation**: `e2.DepartmentID = e1.DepartmentID` – this condition connects each row in the outer query to the rows in the subquery, ensuring the subquery filters data based on the department of each specific employee in the outer query.
3. **Filtering Condition**: The outer query only selects rows where the employee’s salary matches the highest salary found by the subquery.

**Output:**
| EmployeeName | Salary | DepartmentID |
|--------------|--------|--------------|
| Jane         | 7000   | 2            |
| Sara         | 9000   | 2            |

#### How the Correlated Subquery Works Internally

For each employee row in the `Employees` table, SQL Server:
1. **Executes the Subquery**: Finds the maximum salary for the specific `DepartmentID` of the current employee.
2. **Compares Results**: Compares the employee’s salary with the maximum salary for that department.
3. **Returns Rows Matching Condition**: If an employee’s salary equals the department’s maximum, the employee is included in the results.

---

### Another Example: Checking if an Employee Has the Highest Salary in Their Department

If we want to find employees who earn more than the average salary in their department, we can use a correlated subquery to compare each employee’s salary against the department’s average.

```sql
SELECT EmployeeName, Salary, DepartmentID
FROM Employees e1
WHERE Salary > (
    SELECT AVG(Salary)
    FROM Employees e2
    WHERE e2.DepartmentID = e1.DepartmentID
);
```

In this query:
- The subquery calculates the average salary for each department by filtering the `Employees` table based on `DepartmentID` in the outer query.
- For each employee, the subquery calculates the average salary of their department, and the outer query returns only those employees whose salaries are above this average.

**Output:** This would return any employees who earn more than the average salary in their department.

---

### Advantages and Considerations

#### Advantages:
- **Dynamic Filtering**: Correlated subqueries are powerful for cases where data relationships need to be dynamically evaluated row-by-row.
- **Complex Conditions**: They allow complex comparisons that would be difficult to express with simple joins or without the need for additional tables.

#### Considerations:
- **Performance**: Correlated subqueries can be slower, especially with large datasets, because they are executed repeatedly—once per row in the outer query.
- **Optimization**: In some cases, correlated subqueries can be rewritten as joins, which may improve performance by reducing row-by-row execution.

---

### Conclusion

Correlated subqueries are a powerful SQL feature that enables row-level comparisons and filtering, especially for cases where we need to evaluate relationships dynamically. However, due to their potential performance impact, they should be used thoughtfully.

----------------------------------------------------------------------------------------------------------------------------------------------------------

Here's an analysis of each query with comments on any misinterpretations, corrections, and adjustments required for optimal results:

---

### Q1: List Names of Depositors with the Same Branch City as Input Customer’s City

**Current Code:**
```sql
CREATE PROCEDURE sp_list_customer_name
(@CustName VARCHAR(50))
AS
BEGIN
	SELECT d.CNAME, b.BNAME, c.CITY
	FROM DEPOSIT d 
		LEFT JOIN CUSTOMER c ON d.CNAME = c.CNAME
		LEFT JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE
		c.CITY = (SELECT CITY FROM CUSTOMER WHERE CNAME = @CustName)
END

EXECUTE sp_list_customer_name 'NAREN'
```

**Review and Corrections:**
- The **LEFT JOIN** on `CUSTOMER` and `BRANCH` tables is unnecessary; use **INNER JOIN** instead for records that match.
- The code correctly retrieves customers who have deposits in the same city as the input customer’s branch.

**Corrected Code:**
```sql
CREATE PROCEDURE sp_list_customer_name
(@CustName VARCHAR(50))
AS
BEGIN
	SELECT d.CNAME, b.BNAME, c.CITY
	FROM DEPOSIT d
		INNER JOIN CUSTOMER c ON d.CNAME = c.CNAME
		INNER JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE c.CITY = (SELECT CITY FROM CUSTOMER WHERE CNAME = @CustName)
END

EXECUTE sp_list_customer_name 'NAREN';
```

---

### Q2: List All Depositors in JSON Format for Branches Where the Input Customer Has an Account

**Current Code:**
```sql
CREATE PROCEDURE sp_get_depositors
(@CustName VARCHAR(MAX))
AS
BEGIN
	SELECT DISTINCT c.CNAME, d.BNAME, b.CITY 
	FROM CUSTOMER c
		LEFT JOIN BRANCH b ON c.CITY = b.CITY  
		LEFT JOIN DEPOSIT d ON c.CNAME = d.CNAME
	WHERE 
		b.CITY = (SELECT CITY FROM BRANCH WHERE BNAME IN(SELECT BNAME FROM DEPOSIT WHERE CNAME = @CustName))
	FOR JSON PATH
END

EXEC sp_get_depositors 'NAREN';
```

**Review and Corrections:**
- The requirement is to find all depositors who have accounts in the same branches as the input customer. However, the current query is matching **cities** instead of **branches**.
- Use **INNER JOIN** and check directly for branch names.

**Corrected Code:**
```sql
CREATE PROCEDURE sp_get_depositors
(@CustName VARCHAR(50))
AS
BEGIN
	SELECT DISTINCT c.CNAME, d.BNAME, b.CITY 
	FROM CUSTOMER c
		INNER JOIN DEPOSIT d ON c.CNAME = d.CNAME
		INNER JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE d.BNAME IN (SELECT BNAME FROM DEPOSIT WHERE CNAME = @CustName)
	FOR JSON PATH
END

EXEC sp_get_depositors 'NAREN';
```

---

### Q3: Count of Customers in a Given City

**Current Code:**
```sql
CREATE PROCEDURE sp_get_count_by_city
(@CityName VARCHAR(MAX))
AS
BEGIN
	SELECT COUNT(DISTINCT c.CNAME), c.CITY
	FROM CUSTOMER c INNER JOIN BRANCH b ON c.CITY = b.CITY
	WHERE c.CITY = @CityName
	GROUP BY c.CITY
END

EXEC sp_get_count_by_city 'DELHI'
```

**Review:**
- This query will only count customers who live in a city where there is a branch. If this is the intent, it’s correct; otherwise, remove the join to `BRANCH`.

**Final Code:** (No changes needed if the above is intended)

---

### Q4: List All Customers in Given City with Branch City as Mumbai or Delhi in JSON

**Current Code:**
```sql
CREATE PROCEDURE sp_get_customer_conditional
(@CityName VARCHAR(MAX))
AS
BEGIN
	SELECT d.CNAME, c.CITY AS 'Customer City', d.BNAME AS 'Bank Branch', b.CITY
	FROM CUSTOMER c
		INNER JOIN DEPOSIT d ON c.CNAME = d.CNAME
		INNER JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE b.CITY IN ('MUMBAI','DELHI') AND c.CITY = @CityName
	FOR JSON PATH
END

EXEC sp_get_customer_conditional 'MUMBAI';
```

**Review and Corrections:**
- This query accurately filters customers based on their city and branch city constraints. No changes needed.

---

### Q5: Count of Customers Living in the Same City as Branch Location

**Current Code:**
```sql
CREATE PROCEDURE sp_get_customer_count
AS
BEGIN
	SELECT c.CITY, COUNT(DISTINCT c.CNAME) AS 'Number of Customers'
	FROM CUSTOMER c INNER JOIN BRANCH b ON c.CITY = b.CITY
	GROUP BY c.CITY
END

EXECUTE sp_get_customer_count
```

**Review:**
- This query is correct and fulfills the requirement. No changes needed.

---

### Q6: Insert into `DEPOSIT` Table with JSON Input and Validations

**Current Code:**
```sql
CREATE PROCEDURE sp_json_validation
(@Json_Data VARCHAR(MAX))
AS
BEGIN
	INSERT INTO CUSTOMER
		SELECT * 
		FROM OPENJSON(@Json_Data)
		WITH(
			CNAME VARCHAR(50) '$.CustomerName',
			CITY VARCHAR(50) '$.City'
		);
	
	INSERT INTO DEPOSIT
		SELECT *, GETDATE() AS ADATE 
		FROM OPENJSON(@Json_Data) 
		WITH(
			ACTNO VARCHAR(10) '$.ACTNO',
			CNAME VARCHAR(50) '$.CustomerName',
			BNAME VARCHAR(50) '$.Branch',
			AMOUNT INT '$.amount'
		)
		WHERE AMOUNT > 10;
END
```

**Review and Corrections:**
- Currently, there’s no check for existing customers, which may lead to duplication. Use a condition to insert only new customers.
- The code is correct in terms of **JSON parsing** and **validations** for amount and date.

**Corrected Code:**
```sql
CREATE PROCEDURE sp_json_validation
(@Json_Data VARCHAR(MAX))
AS
BEGIN
	-- Insert into CUSTOMER only if the customer does not already exist
	INSERT INTO CUSTOMER
	SELECT CNAME, CITY
	FROM OPENJSON(@Json_Data)
	WITH(
		CNAME VARCHAR(50) '$.CustomerName',
		CITY VARCHAR(50) '$.City'
	) AS new_data
	WHERE NOT EXISTS (SELECT 1 FROM CUSTOMER WHERE CNAME = new_data.CNAME);

	-- Insert into DEPOSIT with validation on amount and current date
	INSERT INTO DEPOSIT
	SELECT ACTNO, CNAME, BNAME, AMOUNT, GETDATE() AS ADATE
	FROM OPENJSON(@Json_Data) 
	WITH(
		ACTNO VARCHAR(10) '$.ACTNO',
		CNAME VARCHAR(50) '$.CustomerName',
		BNAME VARCHAR(50) '$.Branch',
		AMOUNT INT '$.amount'
	)
	WHERE AMOUNT > 10;
END
```

---

-----------------------------------------------------------------------------------------------------------------------------

CREATE TABLE roles (
    roleid INT PRIMARY KEY,
    rolename VARCHAR(50) NOT NULL
);

CREATE TABLE users (
    userid INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    useraddress VARCHAR(500) NOT NULL,
    roleid INT REFERENCES roles(roleid) NOT NULL,
    password VARCHAR(100) NOT NULL
);

CREATE TABLE restaurants (
    restaurantid INT PRIMARY KEY,
    restaurantname VARCHAR(100) NOT NULL,
    restaurantaddress VARCHAR(500) NOT NULL,
    userid INT REFERENCES users(userid) NOT NULL
);

CREATE TABLE items (
    itemid INT PRIMARY KEY,
    itemname VARCHAR(200) NOT NULL
);

CREATE TABLE menu (
    menuid INT PRIMARY KEY,
    itemid INT REFERENCES items(itemid) NOT NULL,
    itemprice MONEY NOT NULL,
    restaurantid INT REFERENCES restaurants(restaurantid) NOT NULL
);

CREATE TABLE cart (
    cartid INT PRIMARY KEY,
    userid INT REFERENCES users(userid) NOT NULL,
    restaurantid INT REFERENCES restaurants(restaurantid) NOT NULL
);

CREATE TABLE cart_items (
    cartid INT REFERENCES cart(cartid),
    itemid INT REFERENCES items(itemid),
    itemquantity INT DEFAULT 1,
    PRIMARY KEY (cartid, itemid)
);

CREATE TABLE paymentstatus (
    statusid INT PRIMARY KEY,
    statusname VARCHAR(100) NOT NULL
);

CREATE TABLE payment (
    paymentid INT PRIMARY KEY,
    cartid INT REFERENCES cart(cartid) NOT NULL,
    userid INT REFERENCES users(userid) NOT NULL,
    amount MONEY NOT NULL,
    statusid INT REFERENCES paymentstatus(statusid) NOT NULL
);

CREATE TABLE delivery (
    deliveryid INT PRIMARY KEY,
    userid INT REFERENCES users(userid) NOT NULL,
    cartid INT REFERENCES cart(cartid) NOT NULL,
    paymentid INT REFERENCES payment(paymentid) NOT NULL
);

--------------------------------------------------------------------------------------------------------------------

CREATE PROCEDURE insertIntoDeposit (
    @insertjson NVARCHAR(MAX)
)
AS
BEGIN
    -- Parse each entry in the JSON array
    DECLARE @Amount INT, @Adate DATE, @ACTNO INT, @Cname NVARCHAR(100), @Bname NVARCHAR(100);
    
    -- Open JSON array and process each item
    DECLARE @json NVARCHAR(MAX) = @insertjson;
    BEGIN TRY
        -- Use OPENJSON to iterate over each item in the JSON array
        WITH JSON_ITEMS AS (
            SELECT *
            FROM OPENJSON(@json)
            WITH (
                ACTNO INT '$.ACTNO',
                Cname NVARCHAR(100) '$.Cname',
                Bname NVARCHAR(100) '$.Bname',
                Amount INT '$.Amount',
                Adate DATE '$.Adate'
            )
        )
        
        INSERT INTO Deposit (ACTNO, Cname, Bname, Amount, Adate)
        SELECT 
            ACTNO,
            Cname,
            Bname,
            Amount,
            Adate
        FROM JSON_ITEMS
        WHERE Amount >= 10
          AND Adate = CAST(GETDATE() AS DATE);

    END TRY
    BEGIN CATCH
        -- Error handling
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        THROW 50000, @ErrorMessage, 1;
    END CATCH
END;

-----------------------------------------------------------------------------------------------------------------------------------

docker restart <container_id>: Restarts a container.

docker exec -it <container_id> <command>: Runs a command inside a running container (e.g., bash for an interactive shell).

docker logs <container_id>: Fetches the logs of a container.

docker network ls: Lists all Docker networks.

docker network create <network_name>: Creates a new Docker network.

docker network connect <network_name> <container_name>: Connects a container to a network.

docker volume ls: Lists all Docker volumes.

-----------------------------------------------------------------------------------------------------------------------------------

Here’s a list of essential Docker commands, organized by category, to help you with your list:

### 1. **Docker Image Commands**

- **`docker build -t <image_name> .`**: Builds an image from a Dockerfile in the current directory, tagging it with `<image_name>`.
- **`docker images`**: Lists all Docker images on the system.
- **`docker rmi <image_name>`**: Removes an image by name or ID.
- **`docker pull <image_name>`**: Pulls an image from a Docker registry (e.g., Docker Hub).
- **`docker tag <source_image> <target_image>`**: Creates a new tag for an image.

### 2. **Docker Container Commands**

- **`docker run -p <host_port>:<container_port> <image_name>`**: Runs a container from an image and maps a host port to the container’s port.
- **`docker ps`**: Lists all running containers.
- **`docker ps -a`**: Lists all containers, including stopped ones.
- **`docker start <container_id>`**: Starts a stopped container.
- **`docker stop <container_id>`**: Stops a running container.
- **`docker restart <container_id>`**: Restarts a container.
- **`docker rm <container_id>`**: Removes a stopped container.
- **`docker exec -it <container_id> <command>`**: Runs a command inside a running container (e.g., `bash` for an interactive shell).
- **`docker logs <container_id>`**: Fetches the logs of a container.

### 3. **Docker Network Commands**

- **`docker network ls`**: Lists all Docker networks.
- **`docker network create <network_name>`**: Creates a new Docker network.
- **`docker network connect <network_name> <container_name>`**: Connects a container to a network.
- **`docker network disconnect <network_name> <container_name>`**: Disconnects a container from a network.

### 4. **Docker Volume Commands**

- **`docker volume create <volume_name>`**: Creates a new volume.
- **`docker volume ls`**: Lists all Docker volumes.
- **`docker volume rm <volume_name>`**: Removes a specific volume.
- **`docker volume inspect <volume_name>`**: Displays detailed information about a volume.

### 5. **Docker Compose Commands** (if using Docker Compose)

- **`docker-compose up`**: Starts containers defined in a `docker-compose.yml` file.
- **`docker-compose up -d`**: Starts containers in detached mode (background).
- **`docker-compose down`**: Stops and removes containers, networks, and volumes created by `docker-compose up`.
- **`docker-compose ps`**: Lists containers defined in the Compose file.
- **`docker-compose logs`**: Shows logs for all services in a Compose setup.

### 6. **Docker System Commands**

- **`docker info`**: Displays system-wide information about Docker.
- **`docker version`**: Displays Docker version details.
- **`docker system prune`**: Removes unused data (containers, images, volumes, networks).
- **`docker stats`**: Displays real-time statistics of running containers (CPU, memory usage).

### 7. **Docker Inspect Commands**

- **`docker inspect <container_id>`**: Provides detailed configuration data of a container or image.
- **`docker inspect <image_id>`**: Provides detailed configuration data of an image.

--------------------------------------------------------------------------------------------------------------------------------------------------------

Here's a categorized list of essential AWS CLI commands to help you get started:

---

### **General AWS CLI Commands**

- **`aws configure`**: Set up AWS CLI with access keys, default region, and output format.
- **`aws help`**: Display a list of commands or get help on a specific command, e.g., `aws s3 help`.
- **`aws sts get-caller-identity`**: Display details about the authenticated user or role.

### **S3 (Simple Storage Service)**

- **`aws s3 ls`**: List all S3 buckets.
- **`aws s3 mb s3://bucket-name`**: Create a new S3 bucket.
- **`aws s3 cp <source> <destination>`**: Copy files to/from S3, e.g., `aws s3 cp file.txt s3://bucket-name/`.
- **`aws s3 rm s3://bucket-name/file.txt`**: Delete a file from an S3 bucket.
- **`aws s3 sync <local-folder> s3://bucket-name`**: Sync a local directory with an S3 bucket.

### **EC2 (Elastic Compute Cloud)**

- **`aws ec2 describe-instances`**: List all EC2 instances.
- **`aws ec2 run-instances --image-id ami-id --instance-type t2.micro`**: Launch a new EC2 instance.
- **`aws ec2 stop-instances --instance-ids i-1234567890abcdef0`**: Stop an EC2 instance.
- **`aws ec2 start-instances --instance-ids i-1234567890abcdef0`**: Start an EC2 instance.
- **`aws ec2 terminate-instances --instance-ids i-1234567890abcdef0`**: Terminate an EC2 instance.

### **IAM (Identity and Access Management)**

- **`aws iam list-users`**: List all IAM users.
- **`aws iam create-user --user-name user-name`**: Create a new IAM user.
- **`aws iam delete-user --user-name user-name`**: Delete an IAM user.
- **`aws iam list-roles`**: List all IAM roles.
- **`aws iam attach-user-policy --user-name user-name --policy-arn policy-arn`**: Attach a policy to a user.

### **RDS (Relational Database Service)**

- **`aws rds describe-db-instances`**: List RDS instances.
- **`aws rds create-db-instance`**: Create a new RDS instance.
- **`aws rds stop-db-instance --db-instance-identifier db-instance-id`**: Stop an RDS instance.
- **`aws rds start-db-instance --db-instance-identifier db-instance-id`**: Start an RDS instance.
- **`aws rds delete-db-instance --db-instance-identifier db-instance-id`**: Delete an RDS instance.

### **CloudFront**

- **`aws cloudfront create-distribution --origin-domain-name example-bucket.s3.amazonaws.com`**: Create a new CloudFront distribution.
- **`aws cloudfront list-distributions`**: List all CloudFront distributions.
- **`aws cloudfront delete-distribution --id distribution-id`**: Delete a CloudFront distribution.

### **Elastic Beanstalk**

- **`aws elasticbeanstalk create-application --application-name my-app`**: Create a new Elastic Beanstalk application.
- **`aws elasticbeanstalk create-environment --application-name my-app --environment-name my-env --solution-stack-name "64bit Amazon Linux 2 v3.1.0 running Node.js 12"`**: Launch a new environment.
- **`aws elasticbeanstalk terminate-environment --environment-name my-env`**: Terminate an Elastic Beanstalk environment.

### **VPC (Virtual Private Cloud)**

- **`aws ec2 create-vpc --cidr-block 10.0.0.0/16`**: Create a new VPC.
- **`aws ec2 describe-vpcs`**: List all VPCs.
- **`aws ec2 delete-vpc --vpc-id vpc-id`**: Delete a VPC.

### **Lambda**

- **`aws lambda list-functions`**: List all Lambda functions.
- **`aws lambda create-function --function-name my-function --runtime nodejs14.x --role arn:aws:iam::account-id:role/lambda-role --handler index.handler --zip-file fileb://function.zip`**: Create a new Lambda function.
- **`aws lambda delete-function --function-name my-function`**: Delete a Lambda function.

### **CloudWatch**

- **`aws cloudwatch list-metrics`**: List available CloudWatch metrics.
- **`aws cloudwatch put-metric-alarm`**: Create a new CloudWatch alarm.
- **`aws cloudwatch describe-alarms`**: List all CloudWatch alarms.

### **ECS (Elastic Container Service)**

- **`aws ecs list-clusters`**: List all ECS clusters.
- **`aws ecs create-cluster --cluster-name my-cluster`**: Create a new ECS cluster.
- **`aws ecs delete-cluster --cluster-name my-cluster`**: Delete an ECS cluster.

----------------------------------------------------------------------------------------------------------------------------------------------------------

Here’s how to approach each of your Docker tasks step-by-step:

---

### **Practice 1: Deploy Vite JS Project Using Multi-Stage Build**

1. **Create a Multi-Stage Dockerfile**:
   ```dockerfile
   # Stage 1: Build the project
   FROM node:16 as builder
   WORKDIR /app
   COPY . .
   RUN npm install
   RUN npm run build

   # Stage 2: Serve the project with NGINX
   FROM nginx:alpine
   COPY --from=builder /app/dist /usr/share/nginx/html
   EXPOSE 5000
   CMD ["nginx", "-g", "daemon off;"]
   ```

2. **Build and Run the Docker Image**:
   ```bash
   docker build -t vite-multi-stage .
   docker run -p 5000:80 vite-multi-stage
   ```

---

### **Practice 2: Deploy Vite JS Project Using Docker Compose**

1. **Create a `docker-compose.yml` File**:
   ```yaml
   version: '3.8'
   services:
     vite:
       build:
         context: .
         dockerfile: Dockerfile
       volumes:
         - .:/app
       ports:
         - "5001:5173"
       command: ["npm", "run", "dev"]
   ```

2. **Create a Dockerfile for Development**:
   ```dockerfile
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   CMD ["npm", "run", "dev"]
   ```

3. **Run the Application with Docker Compose**:
   ```bash
   docker-compose up
   ```

   - Your project will be live at `http://localhost:5001`, with live changes reflecting due to the volume bind.

---

### **Practice 3: Push Docker Image to Docker Hub**

1. **Create a Docker Hub Repository**:
   - Go to Docker Hub and create a new repository (e.g., `vite-practice`).

2. **Tag the Docker Image**:
   ```bash
   docker tag vite-multi-stage your-dockerhub-username/vite-practice:latest
   ```

3. **Login to Docker Hub**:
   ```bash
   docker login
   ```

4. **Push the Image to Docker Hub**:
   ```bash
   docker push your-dockerhub-username/vite-practice:latest
   ```

---

### **Assignment 1: Deploy and Push Using Docker Compose**

1. **Create `docker-compose.yml` File**:
   ```yaml
   version: '3.8'
   services:
     vite:
       image: node:latest
       volumes:
         - .:/app
       working_dir: /app
       ports:
         - "5002:5173"
       command: ["npm", "run", "dev"]
   ```

2. **Run the Docker Compose Application**:
   ```bash
   docker-compose up
   ```

3. **Build and Push the Image to Docker Hub**:
   ```bash
   docker build -t your-dockerhub-username/htmlrepo:latest .
   docker push your-dockerhub-username/htmlrepo:latest
   ```

   - Ensure the repository name is `HTMLrepo`.

---

Let me know if you need additional clarification or help with any specific step!
