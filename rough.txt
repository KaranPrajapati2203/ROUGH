In SQL Server, there are several built-in stored procedures and system views that are commonly used for tasks related to database management, metadata retrieval, and troubleshooting. Here’s a list of some of the most frequently used ones:

---

### Commonly Used Built-In Stored Procedures

1. **sp_help**  
   - Provides details about an object, such as a table, view, or stored procedure.
   - Usage: `EXEC sp_help 'TableName'`

2. **sp_who** and **sp_who2**  
   - Displays information about current users, sessions, and processes.
   - Usage: `EXEC sp_who` or `EXEC sp_who2`

3. **sp_lock**  
   - Shows information about locks currently held by active processes.
   - Usage: `EXEC sp_lock`

4. **sp_executesql**  
   - Executes dynamic SQL and is often used for parameterized queries.
   - Usage: `EXEC sp_executesql N'SELECT * FROM TableName WHERE Column = @Param', N'@Param INT', @Param = 10`

5. **sp_rename**  
   - Renames a database object, such as a table or column.
   - Usage: `EXEC sp_rename 'OldName', 'NewName'`

6. **sp_adduser** and **sp_addlogin**  
   - Creates a new user or login in the SQL Server instance.
   - Usage: `EXEC sp_adduser 'username'`

7. **sp_helpindex**  
   - Lists all indexes on a specified table.
   - Usage: `EXEC sp_helpindex 'TableName'`

8. **sp_helpconstraint**  
   - Shows constraints (like primary key, foreign key) on a specified table.
   - Usage: `EXEC sp_helpconstraint 'TableName'`

9. **sp_configure**  
   - Configures server-level settings.
   - Usage: `EXEC sp_configure 'setting_name', value`

10. **sp_tables**  
    - Provides a list of all tables and views in the current database.
    - Usage: `EXEC sp_tables`

---

### Commonly Used System Views

1. **sys.tables**  
   - Contains a row for each table object in the database.
   - Usage: `SELECT * FROM sys.tables`

2. **sys.columns**  
   - Lists all columns for tables and views within the database.
   - Usage: `SELECT * FROM sys.columns`

3. **sys.indexes**  
   - Provides information about indexes on tables and views.
   - Usage: `SELECT * FROM sys.indexes`

4. **sys.objects**  
   - Contains a row for each object (tables, views, procedures, etc.) in the database.
   - Usage: `SELECT * FROM sys.objects`

5. **sys.procedures**  
   - Contains information about all stored procedures in the database.
   - Usage: `SELECT * FROM sys.procedures`

6. **sys.dm_exec_sessions**  
   - Provides session-level information for active connections.
   - Usage: `SELECT * FROM sys.dm_exec_sessions`

7. **sys.dm_exec_requests**  
   - Displays information about each request currently being executed.
   - Usage: `SELECT * FROM sys.dm_exec_requests`

8. **sys.dm_exec_query_stats**  
   - Contains aggregate performance statistics for cached query plans.
   - Usage: `SELECT * FROM sys.dm_exec_query_stats`

9. **sys.dm_tran_locks**  
   - Provides details about active locks and transactions.
   - Usage: `SELECT * FROM sys.dm_tran_locks`

10. **information_schema.tables**  
    - Standardized view that shows table metadata.
    - Usage: `SELECT * FROM information_schema.tables`

---

These stored procedures and views are commonly used for database management, querying metadata, analyzing performance, and managing user sessions.

-----------------------------------------------------------------------------------------------------------------------------

### 1. **Use of `STRING_SPLIT` in SQL Server**

`STRING_SPLIT` is a function in SQL Server that splits a string into rows based on a specified delimiter. It’s especially helpful when you have a comma-separated string and want to convert it into rows.

#### Example:
Suppose you have a string of comma-separated values and want to get each value on a new row.

```sql
DECLARE @Colors NVARCHAR(100) = 'Red,Green,Blue,Yellow'

SELECT value AS Color
FROM STRING_SPLIT(@Colors, ',')
```

**Output:**
| Color   |
|---------|
| Red     |
| Green   |
| Blue    |
| Yellow  |

In this example, `STRING_SPLIT` takes the `@Colors` string and splits it based on the comma delimiter, returning each color as a separate row.

---

### 2. **Simple Example of a Correlated Subquery**

A **correlated subquery** is a subquery that refers to a column from the outer query. The subquery is executed once for each row processed by the outer query.

#### Example:
Consider two tables: `Employees` and `Departments`.

- `Employees` table:
  | EmployeeID | EmployeeName | DepartmentID |
  |------------|--------------|--------------|
  | 1          | John         | 1            |
  | 2          | Jane         | 2            |
  | 3          | Mike         | 1            |
  | 4          | Sara         | 3            |

- `Departments` table:
  | DepartmentID | DepartmentName |
  |--------------|----------------|
  | 1            | Sales          |
  | 2            | Marketing      |
  | 3            | IT             |

Suppose you want to find employees whose department has more than one employee.

Here’s how you can use a correlated subquery:

```sql
SELECT EmployeeName
FROM Employees e1
WHERE (SELECT COUNT(*)
       FROM Employees e2
       WHERE e2.DepartmentID = e1.DepartmentID) > 1
```

**Explanation:**
- The outer query (`SELECT EmployeeName FROM Employees e1`) retrieves each employee.
- The correlated subquery `(SELECT COUNT(*) FROM Employees e2 WHERE e2.DepartmentID = e1.DepartmentID)` calculates the number of employees in the same department as the current employee (`e1`).
- If the count is greater than 1, the employee is selected in the result.

**Output:**
| EmployeeName |
|--------------|
| John         |
| Mike         |

In this case, `John` and `Mike` are both in the `Sales` department, which has more than one employee, so they are included in the output.

------------------------------------------------------------------------------------------------------------------------------

DECLARE @counter INT = 1;

WHILE @counter <= 5000
BEGIN
    INSERT INTO Employees (EmployeeName, Salary, DepartmentID)
    VALUES (
        CONCAT('Employee', @counter),              -- EmployeeName
        5000 + (RAND() * 5000),                    -- Random Salary between 5000 and 10000
        1 + (ABS(CHECKSUM(NEWID())) % 3)           -- Random DepartmentID (1, 2, or 3)
    );
    SET @counter = @counter + 1;
END;


---------------------------------------------------------------------------------------------------------------------

Correlated subqueries in SQL are subqueries that depend on values from the outer query, which makes them unique because they are evaluated once for each row processed by the outer query. In a correlated subquery, the inner query references a column from the outer query, so it "correlates" with each row processed by the outer query. Let’s break down this concept and look at how it works, with examples.

### Key Characteristics of Correlated Subqueries

1. **Dependency on Outer Query**: The inner (subquery) part of a correlated subquery cannot run independently of the outer query because it refers to columns from the outer query.
2. **Row-by-Row Execution**: The inner query is re-evaluated for each row that the outer query processes, which can sometimes lead to performance considerations, especially with large datasets.
3. **Filtering or Aggregation Context**: Correlated subqueries are often used when you need to compare each row in a table with rows in the same table or another table, especially for tasks like finding matches, filtering, or aggregate values that vary for each row.

### Example Scenario

Let’s use the following tables as an example:

- **Employees**:
  | EmployeeID | EmployeeName | Salary | DepartmentID |
  |------------|--------------|--------|--------------|
  | 1          | John         | 5000   | 1            |
  | 2          | Jane         | 7000   | 2            |
  | 3          | Mike         | 6000   | 1            |
  | 4          | Sara         | 9000   | 2            |
  | 5          | Chris        | 5500   | 1            |

- **Departments**:
  | DepartmentID | DepartmentName |
  |--------------|----------------|
  | 1            | Sales          |
  | 2            | Marketing      |

#### Example 1: Finding Employees with the Highest Salary in Each Department

Suppose you want to list the employees who have the highest salary within their respective departments. To achieve this, a correlated subquery can be used.

```sql
SELECT EmployeeName, Salary, DepartmentID
FROM Employees e1
WHERE Salary = (
    SELECT MAX(Salary)
    FROM Employees e2
    WHERE e2.DepartmentID = e1.DepartmentID
);
```

#### Explanation of the Query

1. **Outer Query**: `SELECT EmployeeName, Salary, DepartmentID FROM Employees e1` – this selects the columns from the `Employees` table. Here, `e1` is an alias for `Employees`, allowing us to differentiate between the outer query and the subquery.
2. **Correlated Subquery**: 
   - `(SELECT MAX(Salary) FROM Employees e2 WHERE e2.DepartmentID = e1.DepartmentID)`: The subquery finds the maximum salary in each department.
   - **Correlation**: `e2.DepartmentID = e1.DepartmentID` – this condition connects each row in the outer query to the rows in the subquery, ensuring the subquery filters data based on the department of each specific employee in the outer query.
3. **Filtering Condition**: The outer query only selects rows where the employee’s salary matches the highest salary found by the subquery.

**Output:**
| EmployeeName | Salary | DepartmentID |
|--------------|--------|--------------|
| Jane         | 7000   | 2            |
| Sara         | 9000   | 2            |

#### How the Correlated Subquery Works Internally

For each employee row in the `Employees` table, SQL Server:
1. **Executes the Subquery**: Finds the maximum salary for the specific `DepartmentID` of the current employee.
2. **Compares Results**: Compares the employee’s salary with the maximum salary for that department.
3. **Returns Rows Matching Condition**: If an employee’s salary equals the department’s maximum, the employee is included in the results.

---

### Another Example: Checking if an Employee Has the Highest Salary in Their Department

If we want to find employees who earn more than the average salary in their department, we can use a correlated subquery to compare each employee’s salary against the department’s average.

```sql
SELECT EmployeeName, Salary, DepartmentID
FROM Employees e1
WHERE Salary > (
    SELECT AVG(Salary)
    FROM Employees e2
    WHERE e2.DepartmentID = e1.DepartmentID
);
```

In this query:
- The subquery calculates the average salary for each department by filtering the `Employees` table based on `DepartmentID` in the outer query.
- For each employee, the subquery calculates the average salary of their department, and the outer query returns only those employees whose salaries are above this average.

**Output:** This would return any employees who earn more than the average salary in their department.

---

### Advantages and Considerations

#### Advantages:
- **Dynamic Filtering**: Correlated subqueries are powerful for cases where data relationships need to be dynamically evaluated row-by-row.
- **Complex Conditions**: They allow complex comparisons that would be difficult to express with simple joins or without the need for additional tables.

#### Considerations:
- **Performance**: Correlated subqueries can be slower, especially with large datasets, because they are executed repeatedly—once per row in the outer query.
- **Optimization**: In some cases, correlated subqueries can be rewritten as joins, which may improve performance by reducing row-by-row execution.

---

### Conclusion

Correlated subqueries are a powerful SQL feature that enables row-level comparisons and filtering, especially for cases where we need to evaluate relationships dynamically. However, due to their potential performance impact, they should be used thoughtfully.

----------------------------------------------------------------------------------------------------------------------------------------------------------

Here's an analysis of each query with comments on any misinterpretations, corrections, and adjustments required for optimal results:

---

### Q1: List Names of Depositors with the Same Branch City as Input Customer’s City

**Current Code:**
```sql
CREATE PROCEDURE sp_list_customer_name
(@CustName VARCHAR(50))
AS
BEGIN
	SELECT d.CNAME, b.BNAME, c.CITY
	FROM DEPOSIT d 
		LEFT JOIN CUSTOMER c ON d.CNAME = c.CNAME
		LEFT JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE
		c.CITY = (SELECT CITY FROM CUSTOMER WHERE CNAME = @CustName)
END

EXECUTE sp_list_customer_name 'NAREN'
```

**Review and Corrections:**
- The **LEFT JOIN** on `CUSTOMER` and `BRANCH` tables is unnecessary; use **INNER JOIN** instead for records that match.
- The code correctly retrieves customers who have deposits in the same city as the input customer’s branch.

**Corrected Code:**
```sql
CREATE PROCEDURE sp_list_customer_name
(@CustName VARCHAR(50))
AS
BEGIN
	SELECT d.CNAME, b.BNAME, c.CITY
	FROM DEPOSIT d
		INNER JOIN CUSTOMER c ON d.CNAME = c.CNAME
		INNER JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE c.CITY = (SELECT CITY FROM CUSTOMER WHERE CNAME = @CustName)
END

EXECUTE sp_list_customer_name 'NAREN';
```

---

### Q2: List All Depositors in JSON Format for Branches Where the Input Customer Has an Account

**Current Code:**
```sql
CREATE PROCEDURE sp_get_depositors
(@CustName VARCHAR(MAX))
AS
BEGIN
	SELECT DISTINCT c.CNAME, d.BNAME, b.CITY 
	FROM CUSTOMER c
		LEFT JOIN BRANCH b ON c.CITY = b.CITY  
		LEFT JOIN DEPOSIT d ON c.CNAME = d.CNAME
	WHERE 
		b.CITY = (SELECT CITY FROM BRANCH WHERE BNAME IN(SELECT BNAME FROM DEPOSIT WHERE CNAME = @CustName))
	FOR JSON PATH
END

EXEC sp_get_depositors 'NAREN';
```

**Review and Corrections:**
- The requirement is to find all depositors who have accounts in the same branches as the input customer. However, the current query is matching **cities** instead of **branches**.
- Use **INNER JOIN** and check directly for branch names.

**Corrected Code:**
```sql
CREATE PROCEDURE sp_get_depositors
(@CustName VARCHAR(50))
AS
BEGIN
	SELECT DISTINCT c.CNAME, d.BNAME, b.CITY 
	FROM CUSTOMER c
		INNER JOIN DEPOSIT d ON c.CNAME = d.CNAME
		INNER JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE d.BNAME IN (SELECT BNAME FROM DEPOSIT WHERE CNAME = @CustName)
	FOR JSON PATH
END

EXEC sp_get_depositors 'NAREN';
```

---

### Q3: Count of Customers in a Given City

**Current Code:**
```sql
CREATE PROCEDURE sp_get_count_by_city
(@CityName VARCHAR(MAX))
AS
BEGIN
	SELECT COUNT(DISTINCT c.CNAME), c.CITY
	FROM CUSTOMER c INNER JOIN BRANCH b ON c.CITY = b.CITY
	WHERE c.CITY = @CityName
	GROUP BY c.CITY
END

EXEC sp_get_count_by_city 'DELHI'
```

**Review:**
- This query will only count customers who live in a city where there is a branch. If this is the intent, it’s correct; otherwise, remove the join to `BRANCH`.

**Final Code:** (No changes needed if the above is intended)

---

### Q4: List All Customers in Given City with Branch City as Mumbai or Delhi in JSON

**Current Code:**
```sql
CREATE PROCEDURE sp_get_customer_conditional
(@CityName VARCHAR(MAX))
AS
BEGIN
	SELECT d.CNAME, c.CITY AS 'Customer City', d.BNAME AS 'Bank Branch', b.CITY
	FROM CUSTOMER c
		INNER JOIN DEPOSIT d ON c.CNAME = d.CNAME
		INNER JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE b.CITY IN ('MUMBAI','DELHI') AND c.CITY = @CityName
	FOR JSON PATH
END

EXEC sp_get_customer_conditional 'MUMBAI';
```

**Review and Corrections:**
- This query accurately filters customers based on their city and branch city constraints. No changes needed.

---

### Q5: Count of Customers Living in the Same City as Branch Location

**Current Code:**
```sql
CREATE PROCEDURE sp_get_customer_count
AS
BEGIN
	SELECT c.CITY, COUNT(DISTINCT c.CNAME) AS 'Number of Customers'
	FROM CUSTOMER c INNER JOIN BRANCH b ON c.CITY = b.CITY
	GROUP BY c.CITY
END

EXECUTE sp_get_customer_count
```

**Review:**
- This query is correct and fulfills the requirement. No changes needed.

---

### Q6: Insert into `DEPOSIT` Table with JSON Input and Validations

**Current Code:**
```sql
CREATE PROCEDURE sp_json_validation
(@Json_Data VARCHAR(MAX))
AS
BEGIN
	INSERT INTO CUSTOMER
		SELECT * 
		FROM OPENJSON(@Json_Data)
		WITH(
			CNAME VARCHAR(50) '$.CustomerName',
			CITY VARCHAR(50) '$.City'
		);
	
	INSERT INTO DEPOSIT
		SELECT *, GETDATE() AS ADATE 
		FROM OPENJSON(@Json_Data) 
		WITH(
			ACTNO VARCHAR(10) '$.ACTNO',
			CNAME VARCHAR(50) '$.CustomerName',
			BNAME VARCHAR(50) '$.Branch',
			AMOUNT INT '$.amount'
		)
		WHERE AMOUNT > 10;
END
```

**Review and Corrections:**
- Currently, there’s no check for existing customers, which may lead to duplication. Use a condition to insert only new customers.
- The code is correct in terms of **JSON parsing** and **validations** for amount and date.

**Corrected Code:**
```sql
CREATE PROCEDURE sp_json_validation
(@Json_Data VARCHAR(MAX))
AS
BEGIN
	-- Insert into CUSTOMER only if the customer does not already exist
	INSERT INTO CUSTOMER
	SELECT CNAME, CITY
	FROM OPENJSON(@Json_Data)
	WITH(
		CNAME VARCHAR(50) '$.CustomerName',
		CITY VARCHAR(50) '$.City'
	) AS new_data
	WHERE NOT EXISTS (SELECT 1 FROM CUSTOMER WHERE CNAME = new_data.CNAME);

	-- Insert into DEPOSIT with validation on amount and current date
	INSERT INTO DEPOSIT
	SELECT ACTNO, CNAME, BNAME, AMOUNT, GETDATE() AS ADATE
	FROM OPENJSON(@Json_Data) 
	WITH(
		ACTNO VARCHAR(10) '$.ACTNO',
		CNAME VARCHAR(50) '$.CustomerName',
		BNAME VARCHAR(50) '$.Branch',
		AMOUNT INT '$.amount'
	)
	WHERE AMOUNT > 10;
END
```

---

-----------------------------------------------------------------------------------------------------------------------------

CREATE TABLE roles (
    roleid INT PRIMARY KEY,
    rolename VARCHAR(50) NOT NULL
);

CREATE TABLE users (
    userid INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    useraddress VARCHAR(500) NOT NULL,
    roleid INT REFERENCES roles(roleid) NOT NULL,
    password VARCHAR(100) NOT NULL
);

CREATE TABLE restaurants (
    restaurantid INT PRIMARY KEY,
    restaurantname VARCHAR(100) NOT NULL,
    restaurantaddress VARCHAR(500) NOT NULL,
    userid INT REFERENCES users(userid) NOT NULL
);

CREATE TABLE items (
    itemid INT PRIMARY KEY,
    itemname VARCHAR(200) NOT NULL
);

CREATE TABLE menu (
    menuid INT PRIMARY KEY,
    itemid INT REFERENCES items(itemid) NOT NULL,
    itemprice MONEY NOT NULL,
    restaurantid INT REFERENCES restaurants(restaurantid) NOT NULL
);

CREATE TABLE cart (
    cartid INT PRIMARY KEY,
    userid INT REFERENCES users(userid) NOT NULL,
    restaurantid INT REFERENCES restaurants(restaurantid) NOT NULL
);

CREATE TABLE cart_items (
    cartid INT REFERENCES cart(cartid),
    itemid INT REFERENCES items(itemid),
    itemquantity INT DEFAULT 1,
    PRIMARY KEY (cartid, itemid)
);

CREATE TABLE paymentstatus (
    statusid INT PRIMARY KEY,
    statusname VARCHAR(100) NOT NULL
);

CREATE TABLE payment (
    paymentid INT PRIMARY KEY,
    cartid INT REFERENCES cart(cartid) NOT NULL,
    userid INT REFERENCES users(userid) NOT NULL,
    amount MONEY NOT NULL,
    statusid INT REFERENCES paymentstatus(statusid) NOT NULL
);

CREATE TABLE delivery (
    deliveryid INT PRIMARY KEY,
    userid INT REFERENCES users(userid) NOT NULL,
    cartid INT REFERENCES cart(cartid) NOT NULL,
    paymentid INT REFERENCES payment(paymentid) NOT NULL
);

--------------------------------------------------------------------------------------------------------------------

CREATE PROCEDURE insertIntoDeposit (
    @insertjson NVARCHAR(MAX)
)
AS
BEGIN
    -- Parse each entry in the JSON array
    DECLARE @Amount INT, @Adate DATE, @ACTNO INT, @Cname NVARCHAR(100), @Bname NVARCHAR(100);
    
    -- Open JSON array and process each item
    DECLARE @json NVARCHAR(MAX) = @insertjson;
    BEGIN TRY
        -- Use OPENJSON to iterate over each item in the JSON array
        WITH JSON_ITEMS AS (
            SELECT *
            FROM OPENJSON(@json)
            WITH (
                ACTNO INT '$.ACTNO',
                Cname NVARCHAR(100) '$.Cname',
                Bname NVARCHAR(100) '$.Bname',
                Amount INT '$.Amount',
                Adate DATE '$.Adate'
            )
        )
        
        INSERT INTO Deposit (ACTNO, Cname, Bname, Amount, Adate)
        SELECT 
            ACTNO,
            Cname,
            Bname,
            Amount,
            Adate
        FROM JSON_ITEMS
        WHERE Amount >= 10
          AND Adate = CAST(GETDATE() AS DATE);

    END TRY
    BEGIN CATCH
        -- Error handling
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        THROW 50000, @ErrorMessage, 1;
    END CATCH
END;

-----------------------------------------------------------------------------------------------------------------------------------

docker restart <container_id>: Restarts a container.

docker exec -it <container_id> <command>: Runs a command inside a running container (e.g., bash for an interactive shell).

docker logs <container_id>: Fetches the logs of a container.

docker network ls: Lists all Docker networks.

docker network create <network_name>: Creates a new Docker network.

docker network connect <network_name> <container_name>: Connects a container to a network.

docker volume ls: Lists all Docker volumes.

-----------------------------------------------------------------------------------------------------------------------------------

Here’s a list of essential Docker commands, organized by category, to help you with your list:

### 1. **Docker Image Commands**

- **`docker build -t <image_name> .`**: Builds an image from a Dockerfile in the current directory, tagging it with `<image_name>`.
- **`docker images`**: Lists all Docker images on the system.
- **`docker rmi <image_name>`**: Removes an image by name or ID.
- **`docker pull <image_name>`**: Pulls an image from a Docker registry (e.g., Docker Hub).
- **`docker tag <source_image> <target_image>`**: Creates a new tag for an image.

### 2. **Docker Container Commands**

- **`docker run -p <host_port>:<container_port> <image_name>`**: Runs a container from an image and maps a host port to the container’s port.
- **`docker ps`**: Lists all running containers.
- **`docker ps -a`**: Lists all containers, including stopped ones.
- **`docker start <container_id>`**: Starts a stopped container.
- **`docker stop <container_id>`**: Stops a running container.
- **`docker restart <container_id>`**: Restarts a container.
- **`docker rm <container_id>`**: Removes a stopped container.
- **`docker exec -it <container_id> <command>`**: Runs a command inside a running container (e.g., `bash` for an interactive shell).
- **`docker logs <container_id>`**: Fetches the logs of a container.

### 3. **Docker Network Commands**

- **`docker network ls`**: Lists all Docker networks.
- **`docker network create <network_name>`**: Creates a new Docker network.
- **`docker network connect <network_name> <container_name>`**: Connects a container to a network.
- **`docker network disconnect <network_name> <container_name>`**: Disconnects a container from a network.

### 4. **Docker Volume Commands**

- **`docker volume create <volume_name>`**: Creates a new volume.
- **`docker volume ls`**: Lists all Docker volumes.
- **`docker volume rm <volume_name>`**: Removes a specific volume.
- **`docker volume inspect <volume_name>`**: Displays detailed information about a volume.

### 5. **Docker Compose Commands** (if using Docker Compose)

- **`docker-compose up`**: Starts containers defined in a `docker-compose.yml` file.
- **`docker-compose up -d`**: Starts containers in detached mode (background).
- **`docker-compose down`**: Stops and removes containers, networks, and volumes created by `docker-compose up`.
- **`docker-compose ps`**: Lists containers defined in the Compose file.
- **`docker-compose logs`**: Shows logs for all services in a Compose setup.

### 6. **Docker System Commands**

- **`docker info`**: Displays system-wide information about Docker.
- **`docker version`**: Displays Docker version details.
- **`docker system prune`**: Removes unused data (containers, images, volumes, networks).
- **`docker stats`**: Displays real-time statistics of running containers (CPU, memory usage).

### 7. **Docker Inspect Commands**

- **`docker inspect <container_id>`**: Provides detailed configuration data of a container or image.
- **`docker inspect <image_id>`**: Provides detailed configuration data of an image.

--------------------------------------------------------------------------------------------------------------------------------------------------------

Here's a categorized list of essential AWS CLI commands to help you get started:

---

### **General AWS CLI Commands**

- **`aws configure`**: Set up AWS CLI with access keys, default region, and output format.
- **`aws help`**: Display a list of commands or get help on a specific command, e.g., `aws s3 help`.
- **`aws sts get-caller-identity`**: Display details about the authenticated user or role.

### **S3 (Simple Storage Service)**

- **`aws s3 ls`**: List all S3 buckets.
- **`aws s3 mb s3://bucket-name`**: Create a new S3 bucket.
- **`aws s3 cp <source> <destination>`**: Copy files to/from S3, e.g., `aws s3 cp file.txt s3://bucket-name/`.
- **`aws s3 rm s3://bucket-name/file.txt`**: Delete a file from an S3 bucket.
- **`aws s3 sync <local-folder> s3://bucket-name`**: Sync a local directory with an S3 bucket.

### **EC2 (Elastic Compute Cloud)**

- **`aws ec2 describe-instances`**: List all EC2 instances.
- **`aws ec2 run-instances --image-id ami-id --instance-type t2.micro`**: Launch a new EC2 instance.
- **`aws ec2 stop-instances --instance-ids i-1234567890abcdef0`**: Stop an EC2 instance.
- **`aws ec2 start-instances --instance-ids i-1234567890abcdef0`**: Start an EC2 instance.
- **`aws ec2 terminate-instances --instance-ids i-1234567890abcdef0`**: Terminate an EC2 instance.

### **IAM (Identity and Access Management)**

- **`aws iam list-users`**: List all IAM users.
- **`aws iam create-user --user-name user-name`**: Create a new IAM user.
- **`aws iam delete-user --user-name user-name`**: Delete an IAM user.
- **`aws iam list-roles`**: List all IAM roles.
- **`aws iam attach-user-policy --user-name user-name --policy-arn policy-arn`**: Attach a policy to a user.

### **RDS (Relational Database Service)**

- **`aws rds describe-db-instances`**: List RDS instances.
- **`aws rds create-db-instance`**: Create a new RDS instance.
- **`aws rds stop-db-instance --db-instance-identifier db-instance-id`**: Stop an RDS instance.
- **`aws rds start-db-instance --db-instance-identifier db-instance-id`**: Start an RDS instance.
- **`aws rds delete-db-instance --db-instance-identifier db-instance-id`**: Delete an RDS instance.

### **CloudFront**

- **`aws cloudfront create-distribution --origin-domain-name example-bucket.s3.amazonaws.com`**: Create a new CloudFront distribution.
- **`aws cloudfront list-distributions`**: List all CloudFront distributions.
- **`aws cloudfront delete-distribution --id distribution-id`**: Delete a CloudFront distribution.

### **Elastic Beanstalk**

- **`aws elasticbeanstalk create-application --application-name my-app`**: Create a new Elastic Beanstalk application.
- **`aws elasticbeanstalk create-environment --application-name my-app --environment-name my-env --solution-stack-name "64bit Amazon Linux 2 v3.1.0 running Node.js 12"`**: Launch a new environment.
- **`aws elasticbeanstalk terminate-environment --environment-name my-env`**: Terminate an Elastic Beanstalk environment.

### **VPC (Virtual Private Cloud)**

- **`aws ec2 create-vpc --cidr-block 10.0.0.0/16`**: Create a new VPC.
- **`aws ec2 describe-vpcs`**: List all VPCs.
- **`aws ec2 delete-vpc --vpc-id vpc-id`**: Delete a VPC.

### **Lambda**

- **`aws lambda list-functions`**: List all Lambda functions.
- **`aws lambda create-function --function-name my-function --runtime nodejs14.x --role arn:aws:iam::account-id:role/lambda-role --handler index.handler --zip-file fileb://function.zip`**: Create a new Lambda function.
- **`aws lambda delete-function --function-name my-function`**: Delete a Lambda function.

### **CloudWatch**

- **`aws cloudwatch list-metrics`**: List available CloudWatch metrics.
- **`aws cloudwatch put-metric-alarm`**: Create a new CloudWatch alarm.
- **`aws cloudwatch describe-alarms`**: List all CloudWatch alarms.

### **ECS (Elastic Container Service)**

- **`aws ecs list-clusters`**: List all ECS clusters.
- **`aws ecs create-cluster --cluster-name my-cluster`**: Create a new ECS cluster.
- **`aws ecs delete-cluster --cluster-name my-cluster`**: Delete an ECS cluster.

----------------------------------------------------------------------------------------------------------------------------------------------------------

Here’s how to approach each of your Docker tasks step-by-step:

---

### **Practice 1: Deploy Vite JS Project Using Multi-Stage Build**

1. **Create a Multi-Stage Dockerfile**:
   ```dockerfile
   # Stage 1: Build the project
   FROM node:16 as builder
   WORKDIR /app
   COPY . .
   RUN npm install
   RUN npm run build

   # Stage 2: Serve the project with NGINX
   FROM nginx:alpine
   COPY --from=builder /app/dist /usr/share/nginx/html
   EXPOSE 5000
   CMD ["nginx", "-g", "daemon off;"]
   ```

2. **Build and Run the Docker Image**:
   ```bash
   docker build -t vite-multi-stage .
   docker run -p 5000:80 vite-multi-stage
   ```

---

### **Practice 2: Deploy Vite JS Project Using Docker Compose**

1. **Create a `docker-compose.yml` File**:
   ```yaml
   version: '3.8'
   services:
     vite:
       build:
         context: .
         dockerfile: Dockerfile
       volumes:
         - .:/app
       ports:
         - "5001:5173"
       command: ["npm", "run", "dev"]
   ```

2. **Create a Dockerfile for Development**:
   ```dockerfile
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   CMD ["npm", "run", "dev"]
   ```

3. **Run the Application with Docker Compose**:
   ```bash
   docker-compose up
   ```

   - Your project will be live at `http://localhost:5001`, with live changes reflecting due to the volume bind.

---

### **Practice 3: Push Docker Image to Docker Hub**

1. **Create a Docker Hub Repository**:
   - Go to Docker Hub and create a new repository (e.g., `vite-practice`).

2. **Tag the Docker Image**:
   ```bash
   docker tag vite-multi-stage your-dockerhub-username/vite-practice:latest
   ```

3. **Login to Docker Hub**:
   ```bash
   docker login
   ```

4. **Push the Image to Docker Hub**:
   ```bash
   docker push your-dockerhub-username/vite-practice:latest
   ```

---

### **Assignment 1: Deploy and Push Using Docker Compose**

1. **Create `docker-compose.yml` File**:
   ```yaml
   version: '3.8'
   services:
     vite:
       image: node:latest
       volumes:
         - .:/app
       working_dir: /app
       ports:
         - "5002:5173"
       command: ["npm", "run", "dev"]
   ```

2. **Run the Docker Compose Application**:
   ```bash
   docker-compose up
   ```

3. **Build and Push the Image to Docker Hub**:
   ```bash
   docker build -t your-dockerhub-username/htmlrepo:latest .
   docker push your-dockerhub-username/htmlrepo:latest
   ```

   - Ensure the repository name is `HTMLrepo`.

---

Let me know if you need additional clarification or help with any specific step!

-----------------------------------------------------------------------------------------------------

Subject: Leave Request for 23rd November 2024

Dear [Reporting Head's Name],

I hope this email finds you well. I am writing to formally request leave for Saturday, 23rd November 2024, to attend a family function and a wedding.

I have ensured that my current tasks are on track and will make the necessary arrangements to complete any pending work before my leave, to minimize any disruption. If there are any urgent tasks or priorities, please let me know, and I will address them in advance.

Thank you for considering my request. Please let me know if any additional information is required.

Warm regards,
[Your Full Name]
Trainee – Software Development
[Your Contact Information, if necessary]

--------------------------------------------------------------------------------------------------------

I have learned the concepts of sql server, now i want to do hands on implementation. Give 10 questions each for the topics
1. Stored procedure
2. Derived Table
3. CTE
4. Views
5. Temp table
6. Trigger
7. cursor
8. Functions
9. Indexes
10. Common SQL server tasks to test DML,DQL,in built date,string and match functions
Create 3 tables that have relation among them (give create query with some real dummy data inserted)
Make sure these questions contains all the necessary topics of sql server so that I can practice and can get good command of sql server.
Do not give easy question, keep the level between moderate and difficult

-------------------------------------------------------------------------------------------------------------------

### Database Schema: Related Tables

```sql
-- Create Tables
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    CustomerName NVARCHAR(100),
    City NVARCHAR(50)
);

CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT FOREIGN KEY REFERENCES Customers(CustomerID),
    OrderDate DATE,
    TotalAmount DECIMAL(10, 2)
);

CREATE TABLE OrderDetails (
    OrderDetailID INT PRIMARY KEY,
    OrderID INT FOREIGN KEY REFERENCES Orders(OrderID),
    ProductName NVARCHAR(100),
    Quantity INT,
    Price DECIMAL(10, 2)
);

-- Insert Data for Customers
INSERT INTO Customers VALUES
(1, 'Rahul Sharma', 'Mumbai'),
(2, 'Anjali Verma', 'Delhi'),
(3, 'Ravi Kumar', 'Chennai'),
(4, 'Pooja Singh', 'Bengaluru'),
(5, 'Vikram Joshi', 'Kolkata'),
(6, 'Neha Mehta', 'Pune'),
(7, 'Amit Gupta', 'Hyderabad'),
(8, 'Priya Das', 'Jaipur'),
(9, 'Arjun Reddy', 'Ahmedabad'),
(10, 'Deepa Nair', 'Thiruvananthapuram'),
(11, 'Karan Malhotra', 'Lucknow'),
(12, 'Sanya Iyer', 'Mysuru'),
(13, 'Manish Kapoor', 'Chandigarh'),
(14, 'Meera Choudhary', 'Bhopal'),
(15, 'Siddharth Mishra', 'Nagpur'),
(16, 'Ritika Jain', 'Surat'),
(17, 'Akash Patel', 'Vadodara'),
(18, 'Swati Sharma', 'Patna'),
(19, 'Nitin Deshmukh', 'Indore'),
(20, 'Roshni Singh', 'Jodhpur'),
(21, 'Rajesh Khanna', 'Coimbatore'),
(22, 'Sonal Agarwal', 'Amritsar'),
(23, 'Varun Tiwari', 'Ranchi'),
(24, 'Ishita Sen', 'Guwahati'),
(25, 'Aditya Goyal', 'Agra');

-- Insert Data for Orders
INSERT INTO Orders VALUES
(101, 1, '2024-10-01', 250.00),
(102, 2, '2024-10-05', 450.00),
(103, 3, '2024-10-10', 100.00),
(104, 4, '2024-10-12', 600.00),
(105, 5, '2024-10-15', 800.00),
(106, 6, '2024-10-18', 300.00),
(107, 7, '2024-10-20', 1200.00),
(108, 8, '2024-10-22', 500.00),
(109, 9, '2024-10-25', 750.00),
(110, 10, '2024-10-28', 400.00),
(111, 11, '2024-10-30', 550.00),
(112, 12, '2024-11-01', 900.00),
(113, 13, '2024-11-03', 350.00),
(114, 14, '2024-11-06', 250.00),
(115, 15, '2024-11-08', 700.00),
(116, 16, '2024-11-10', 200.00),
(117, 17, '2024-11-12', 100.00),
(118, 18, '2024-11-14', 450.00),
(119, 19, '2024-11-16', 650.00),
(120, 20, '2024-11-18', 300.00),
(121, 21, '2024-11-20', 480.00),
(122, 22, '2024-11-22', 520.00),
(123, 23, '2024-11-24', 410.00),
(124, 24, '2024-11-26', 700.00),
(125, 25, '2024-11-28', 900.00);

-- Insert Data for OrderDetails
INSERT INTO OrderDetails VALUES
(1, 101, 'Laptop', 1, 250.00),
(2, 102, 'Smartphone', 2, 225.00),
(3, 103, 'Headphones', 2, 50.00),
(4, 104, 'Tablet', 2, 300.00),
(5, 105, 'Desktop', 1, 800.00),
(6, 106, 'Smartwatch', 2, 150.00),
(7, 107, 'Gaming Console', 1, 1200.00),
(8, 108, 'Wireless Earbuds', 2, 250.00),
(9, 109, 'Printer', 1, 750.00),
(10, 110, 'Keyboard', 4, 100.00),
(11, 111, 'Monitor', 2, 275.00),
(12, 112, 'Router', 3, 300.00),
(13, 113, 'Power Bank', 5, 350.00),
(14, 114, 'Mouse', 5, 50.00),
(15, 115, 'Camera', 1, 700.00),
(16, 116, 'Speakers', 2, 100.00),
(17, 117, 'Pendrive', 10, 10.00),
(18, 118, 'Projector', 1, 450.00),
(19, 119, 'Webcam', 2, 325.00),
(20, 120, 'VR Headset', 1, 300.00),
(21, 121, 'Hard Drive', 2, 240.00),
(22, 122, 'SSD', 1, 520.00),
(23, 123, 'Graphics Card', 1, 410.00),
(24, 124, 'Motherboard', 1, 700.00),
(25, 125, 'Processor', 1, 900.00);

```

### Practice Questions (Moderate to difficult)

#### 1. Stored Procedures
1. Create a stored procedure to retrieve all orders placed by a specific customer.
2. Create a stored procedure to update the total amount of an order based on its details.
3. Write a procedure to delete a customer by ID and all associated orders and order details.
4. Create a procedure to calculate the total sales for a given date range.
5. Write a procedure to fetch orders where the total amount exceeds a given value.
6. Implement a procedure to archive orders older than a year into a new table.
7. Write a stored procedure to insert a new customer and return the CustomerID.
8. Create a procedure to split orders exceeding a specified amount into smaller orders.
9. Write a procedure that logs changes to the OrderDetails table into an audit table.
10. Implement a stored procedure to bulk insert orders using a TVP (Table-Valued Parameter).

#### 2. Derived Tables
1. Retrieve customers who have placed orders with a total amount greater than the average order total.
2. Use a derived table to find the top three most expensive orders.
3. Fetch the list of customers and their total order amounts using a derived table.
4. Write a query to find products that appear in more than one order using derived tables.
5. Retrieve orders with the highest and lowest total amounts using derived tables.
6. Use a derived table to calculate the total revenue generated per city.
7. Fetch the names of customers who have not placed any orders using derived tables.
8. Identify orders where the number of items exceeds the average items per order.
9. Use a derived table to calculate the rank of each order based on the total amount.
10. Write a query to get the order count for each customer, sorted by the highest count.

#### 3. Common Table Expressions (CTEs)
1. Use a CTE to fetch customers along with their order count.
2. Write a recursive CTE to generate a sequence of numbers (e.g., for pagination).
3. Implement a CTE to find customers whose total order amount exceeds a certain threshold.
4. Use a CTE to retrieve orders grouped by month and calculate monthly totals.
5. Write a CTE to list the top N products by sales.
6. Create a CTE to find customers who placed more than three orders.
7. Use a CTE to find the order with the maximum total amount.
8. Implement a CTE to calculate cumulative totals for each customer.
9. Use a CTE to get hierarchical data (e.g., a self-referencing employee-manager table).
10. Create a CTE to identify gaps in OrderIDs.

#### 4. Views
1. Create a view to show customer details along with their total order amounts.
2. Write a view to display orders and their item details in a flat structure.
3. Create a view to list customers who haven't placed any orders.
4. Write a view to show the monthly sales summary.
5. Create a view to list all orders with details of products priced above a certain value.
6. Design a view to display customers who have placed orders exceeding their city's average.
7. Create a view for frequently ordered products (appearing in more than 5 orders).
8. Write a view to fetch orders placed in the last 6 months.
9. Create a view to show customers along with the number of distinct products they've ordered.
10. Design a view to calculate the average order value per city.

#### 5. Temporary Tables
1. Use a temporary table to store and retrieve the top 5 highest-paying customers.
2. Create a temporary table to calculate and store monthly order totals.
3. Populate a temporary table with customers who have placed at least two orders.
4. Write a query to create a temp table for orders shipped in the last year.
5. Use a temporary table to join OrderDetails with an external dataset.
6. Create a temp table to find duplicate OrderIDs (if any).
7. Use a temp table to store audit logs for modifications to the Customers table.
8. Write a query to store results of complex calculations in a temp table and then filter.
9. Use a temp table to rank customers by their total order amounts.
10. Create a temp table for storing intermediate results of a recursive CTE.

#### 6. Triggers
1. Write a trigger to log all updates to the Customers table into an audit table.
2. Create a trigger to prevent deletion of orders that have shipped.
3. Write a trigger to enforce that no order can exceed $10,000.
4. Implement a trigger to update the total amount in the Orders table after OrderDetails change.
5. Create a trigger to disallow updates to customer names.
6. Write a trigger to automatically archive deleted customers into another table.
7. Implement a trigger to send alerts when orders are placed on weekends.
8. Write a trigger to track changes to product quantities in the OrderDetails table.
9. Create a trigger to prevent adding new products priced below $5.
10. Write a trigger to update a "Last Modified" column in Customers on any change.

#### 7. Cursors
1. Write a cursor to iterate over orders and calculate the average amount for each customer.
2. Create a cursor to fetch and process orders placed in a specific date range.
3. Implement a cursor to update customer status based on total order amount.
4. Write a cursor to delete orders older than a specific date one by one.
5. Use a cursor to fetch customer names and send notifications for their highest-value orders.
6. Write a cursor to adjust product prices in the OrderDetails table.
7. Implement a cursor to calculate cumulative sales per customer.
8. Use a cursor to find and update records with null values in a table.
9. Create a cursor to transfer data from one table to another.
10. Write a cursor to iterate through customers and generate a dynamic report.

#### 8. Functions
1. Create a scalar function to calculate the discount for an order based on its total.
2. Write a function to return the total sales for a given customer.
3. Create a table-valued function to list orders placed within a date range.
4. Write a function to return the number of products in an order.
5. Create a function to calculate the total quantity of items sold for a product.
6. Implement a function to format customer names as "Last, First".
7. Write a function to calculate the tax on an order based on its amount.
8. Create a function to fetch the next available OrderID.
9. Implement a function to check if a customer exists in the database.
10. Write a function to return the average order value for a specific city.

#### 9. Indexes
1. Create an index to optimize queries fetching orders by CustomerID.
2. Design a composite index for queries filtering by OrderDate and TotalAmount.
3. Test performance of queries with and without an index on ProductName in OrderDetails.
4. Implement an index to speed up searches on CustomerName in the Customers table.
5. Create a unique index to enforce no duplicate entries in OrderDetails.
6. Write a query to analyze the impact of indexing OrderIDs.
7. Use the INCLUDE clause in an index for optimizing total amount queries.
8. Create a filtered index for orders with a total amount above $500.
9. Drop and recreate indexes to improve performance on slow queries.
10. Use the SQL Server Profiler to measure query performance before and after indexing.

#### 10. Common SQL Server Tasks
1. Write queries using DML statements to update, delete, and insert records in Orders.
2. Use DQL to fetch the top 5 customers based


------------------------------------------------------------------------------------------------------------

Easy to moderate

### 1. Stored Procedures
1. Create a stored procedure to fetch all orders for a given customer ID.
2. Write a stored procedure to calculate the total sales for a given city.
3. Create a stored procedure to insert a new customer and return the newly inserted CustomerID.
4. Write a stored procedure to update the price of a product in the `OrderDetails` table for a given `OrderDetailID`.
5. Create a stored procedure to delete all orders for a specific customer.
6. Write a stored procedure to fetch all products purchased by customers from a specific city.
7. Create a stored procedure to list orders with a total amount greater than a given threshold.
8. Write a stored procedure to calculate and return the total quantity of a product sold.
9. Create a stored procedure that accepts a date range and returns all orders within that range.
10. Write a stored procedure to update multiple customer names based on a list of `CustomerID` values.

### 2. Derived Tables
1. Find the total amount spent by each customer using a derived table.
2. Fetch the top 3 most expensive products in the `OrderDetails` table using a derived table.
3. Write a query to calculate the average order amount and list customers whose orders exceed this average.
4. Use a derived table to fetch all customers who have placed orders with a total amount greater than $300.
5. Write a query to find the product with the highest quantity sold using a derived table.
6. Use a derived table to calculate the total quantity sold for each product.
7. Fetch customers who haven't placed any orders using a derived table.
8. Use a derived table to list all orders along with the total price of their items.
9. Write a query to find the city with the highest total sales using a derived table.
10. Use a derived table to count the number of orders placed by each customer.

### 3. Common Table Expressions (CTE)
1. Write a CTE to find the total sales amount for each customer.
2. Use a CTE to list all products and their total sales amounts.
3. Write a recursive CTE to generate a sequence of numbers (e.g., for pagination purposes).
4. Use a CTE to find all orders placed in the last 30 days.
5. Create a CTE to rank customers by their total spending.
6. Use a CTE to fetch all products with a total quantity sold greater than 1.
7. Write a CTE to calculate the cumulative total sales for all orders.
8. Create a CTE to list the average order amount for each city.
9. Use a CTE to fetch the most recent order for each customer.
10. Write a CTE to find customers who have placed more than one order.

### 4. Views
1. Create a view to list all orders with their customer names and total amounts.
2. Create a view to display the total quantity sold for each product.
3. Write a view to fetch all customers who have placed orders along with their order count.
4. Create a view to show the details of orders placed in the current year.
5. Write a view to fetch the top 5 customers by total spending.
6. Create a view to display all products with their total sales amount and quantity.
7. Create a view to fetch the orders along with their details in a single result set.
8. Write a view to fetch all customers and their cities with their total order amount.
9. Create a view to display all orders with their order date and the names of customers.
10. Write a view to fetch all products sold in orders with a total amount greater than $200.

### 5. Temporary Tables
1. Create a temporary table to store the total sales amount for each customer and fetch the top spender.
2. Write a query to store all orders placed in the last month into a temporary table and display them.
3. Use a temporary table to calculate the total quantity sold for each product and fetch products with quantities greater than 2.
4. Write a query to fetch all customers from New York and store them in a temporary table.
5. Use a temporary table to list all orders along with their total price.
6. Store all orders for a specific customer into a temporary table and calculate their total amount.
7. Create a temporary table to store all orders with a total amount greater than $300 and fetch the results.
8. Write a query to store the total sales amount for each city into a temporary table.
9. Use a temporary table to fetch the details of all orders placed in the last 7 days.
10. Create a temporary table to list all products with their total sales amounts.

### 6. Triggers
1. Create a trigger to log changes to the `Orders` table into an audit table.
2. Write a trigger to prevent the deletion of customers who have active orders.
3. Create a trigger to automatically update the `TotalAmount` in the `Orders` table when a new `OrderDetail` is added.
4. Write a trigger to send an alert when an order exceeds a total amount of $500.
5. Create a trigger to log changes to the `Customers` table into an audit table.
6. Write a trigger to prevent the insertion of orders with a total amount less than $50.
7. Create a trigger to automatically update the total quantity of a product in the `OrderDetails` table.
8. Write a trigger to log all deletions from the `OrderDetails` table.
9. Create a trigger to prevent updates to the `CustomerName` in the `Customers` table.
10. Write a trigger to automatically insert a default value for `Price` if it is not provided in the `OrderDetails` table.

### 7. Cursors
1. Write a cursor to iterate through all customers and print their names and cities.
2. Use a cursor to calculate the total sales for each customer and display the results.
3. Write a cursor to fetch all orders and update their total amounts with a 10% discount.
4. Use a cursor to list all products with their total quantities sold.
5. Write a cursor to iterate through all orders placed in the last 7 days.
6. Use a cursor to calculate and update the total sales for each city in a temporary table.
7. Write a cursor to fetch all orders and print their details along with the customer names.
8. Use a cursor to iterate through all customers and fetch their order history.
9. Write a cursor to list all orders along with their total amounts in a readable format.
10. Use a cursor to find and print all products sold in orders with a total amount greater than $200.

### 8. Functions
1. Create a scalar function to calculate the total price of an order given its `OrderID`.
2. Write a scalar function to fetch the total quantity sold for a given product name.
3. Create a table-valued function to list all orders for a specific customer.
4. Write a scalar function to fetch the total sales amount for a given city.
5. Create a scalar function to return the number of orders placed by a specific customer.
6. Write a table-valued function to fetch all products with their total sales amounts.
7. Create a scalar function to calculate the average order amount for a given city.
8. Write a scalar function to fetch the highest order amount placed by a customer.
9. Create a table-valued function to list all orders placed within a specific date range.
10. Write a scalar function to fetch the total revenue generated by a specific product.

### 9. Indexes
1. Create an index on the `City` column of the `Customers` table and test its performance.
2. Write a query to fetch all orders for a specific customer and analyze the effect of indexing on `CustomerID`.
3. Create a composite index on `OrderDate` and `TotalAmount` in the `Orders` table and test its effect.
4. Write a query to fetch the details of a specific order and test the impact of indexing `OrderID`.
5. Create a non-clustered index on the `ProductName` column in the `OrderDetails` table and analyze its performance.
6. Test the performance of a query fetching all orders placed within a specific date range with and without an index on `OrderDate`.
7. Create an index on the `CustomerName` column in the `Customers` table and test its effect on search queries.
8. Write a query to fetch all products with their total quantities sold and analyze the impact of indexing on `Price`.
9. Create an index on `TotalAmount` in the `Orders` table and test its effect on aggregate queries.
10. Analyze the impact of indexing on the `City` column in the `Customers` table for city-specific queries.

### 10. Common SQL Server Tasks
1. Write a query to calculate the total revenue generated from all orders.
2. Use DML to update the price of a product in the `OrderDetails` table.
3. Write a query using DQL to fetch all orders placed in the current year.
4. Use a built-in date function to fetch all orders placed in the last 30 days.
5. Write a query using a string function to find customers whose names contain the letter "a"



