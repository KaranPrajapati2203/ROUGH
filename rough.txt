In SQL Server, there are several built-in stored procedures and system views that are commonly used for tasks related to database management, metadata retrieval, and troubleshooting. Here’s a list of some of the most frequently used ones:

---

### Commonly Used Built-In Stored Procedures

1. **sp_help**  
   - Provides details about an object, such as a table, view, or stored procedure.
   - Usage: `EXEC sp_help 'TableName'`

2. **sp_who** and **sp_who2**  
   - Displays information about current users, sessions, and processes.
   - Usage: `EXEC sp_who` or `EXEC sp_who2`

3. **sp_lock**  
   - Shows information about locks currently held by active processes.
   - Usage: `EXEC sp_lock`

4. **sp_executesql**  
   - Executes dynamic SQL and is often used for parameterized queries.
   - Usage: `EXEC sp_executesql N'SELECT * FROM TableName WHERE Column = @Param', N'@Param INT', @Param = 10`

5. **sp_rename**  
   - Renames a database object, such as a table or column.
   - Usage: `EXEC sp_rename 'OldName', 'NewName'`

6. **sp_adduser** and **sp_addlogin**  
   - Creates a new user or login in the SQL Server instance.
   - Usage: `EXEC sp_adduser 'username'`

7. **sp_helpindex**  
   - Lists all indexes on a specified table.
   - Usage: `EXEC sp_helpindex 'TableName'`

8. **sp_helpconstraint**  
   - Shows constraints (like primary key, foreign key) on a specified table.
   - Usage: `EXEC sp_helpconstraint 'TableName'`

9. **sp_configure**  
   - Configures server-level settings.
   - Usage: `EXEC sp_configure 'setting_name', value`

10. **sp_tables**  
    - Provides a list of all tables and views in the current database.
    - Usage: `EXEC sp_tables`

---

### Commonly Used System Views

1. **sys.tables**  
   - Contains a row for each table object in the database.
   - Usage: `SELECT * FROM sys.tables`

2. **sys.columns**  
   - Lists all columns for tables and views within the database.
   - Usage: `SELECT * FROM sys.columns`

3. **sys.indexes**  
   - Provides information about indexes on tables and views.
   - Usage: `SELECT * FROM sys.indexes`

4. **sys.objects**  
   - Contains a row for each object (tables, views, procedures, etc.) in the database.
   - Usage: `SELECT * FROM sys.objects`

5. **sys.procedures**  
   - Contains information about all stored procedures in the database.
   - Usage: `SELECT * FROM sys.procedures`

6. **sys.dm_exec_sessions**  
   - Provides session-level information for active connections.
   - Usage: `SELECT * FROM sys.dm_exec_sessions`

7. **sys.dm_exec_requests**  
   - Displays information about each request currently being executed.
   - Usage: `SELECT * FROM sys.dm_exec_requests`

8. **sys.dm_exec_query_stats**  
   - Contains aggregate performance statistics for cached query plans.
   - Usage: `SELECT * FROM sys.dm_exec_query_stats`

9. **sys.dm_tran_locks**  
   - Provides details about active locks and transactions.
   - Usage: `SELECT * FROM sys.dm_tran_locks`

10. **information_schema.tables**  
    - Standardized view that shows table metadata.
    - Usage: `SELECT * FROM information_schema.tables`

---

These stored procedures and views are commonly used for database management, querying metadata, analyzing performance, and managing user sessions.

-----------------------------------------------------------------------------------------------------------------------------

### 1. **Use of `STRING_SPLIT` in SQL Server**

`STRING_SPLIT` is a function in SQL Server that splits a string into rows based on a specified delimiter. It’s especially helpful when you have a comma-separated string and want to convert it into rows.

#### Example:
Suppose you have a string of comma-separated values and want to get each value on a new row.

```sql
DECLARE @Colors NVARCHAR(100) = 'Red,Green,Blue,Yellow'

SELECT value AS Color
FROM STRING_SPLIT(@Colors, ',')
```

**Output:**
| Color   |
|---------|
| Red     |
| Green   |
| Blue    |
| Yellow  |

In this example, `STRING_SPLIT` takes the `@Colors` string and splits it based on the comma delimiter, returning each color as a separate row.

---

### 2. **Simple Example of a Correlated Subquery**

A **correlated subquery** is a subquery that refers to a column from the outer query. The subquery is executed once for each row processed by the outer query.

#### Example:
Consider two tables: `Employees` and `Departments`.

- `Employees` table:
  | EmployeeID | EmployeeName | DepartmentID |
  |------------|--------------|--------------|
  | 1          | John         | 1            |
  | 2          | Jane         | 2            |
  | 3          | Mike         | 1            |
  | 4          | Sara         | 3            |

- `Departments` table:
  | DepartmentID | DepartmentName |
  |--------------|----------------|
  | 1            | Sales          |
  | 2            | Marketing      |
  | 3            | IT             |

Suppose you want to find employees whose department has more than one employee.

Here’s how you can use a correlated subquery:

```sql
SELECT EmployeeName
FROM Employees e1
WHERE (SELECT COUNT(*)
       FROM Employees e2
       WHERE e2.DepartmentID = e1.DepartmentID) > 1
```

**Explanation:**
- The outer query (`SELECT EmployeeName FROM Employees e1`) retrieves each employee.
- The correlated subquery `(SELECT COUNT(*) FROM Employees e2 WHERE e2.DepartmentID = e1.DepartmentID)` calculates the number of employees in the same department as the current employee (`e1`).
- If the count is greater than 1, the employee is selected in the result.

**Output:**
| EmployeeName |
|--------------|
| John         |
| Mike         |

In this case, `John` and `Mike` are both in the `Sales` department, which has more than one employee, so they are included in the output.

------------------------------------------------------------------------------------------------------------------------------

DECLARE @counter INT = 1;

WHILE @counter <= 5000
BEGIN
    INSERT INTO Employees (EmployeeName, Salary, DepartmentID)
    VALUES (
        CONCAT('Employee', @counter),              -- EmployeeName
        5000 + (RAND() * 5000),                    -- Random Salary between 5000 and 10000
        1 + (ABS(CHECKSUM(NEWID())) % 3)           -- Random DepartmentID (1, 2, or 3)
    );
    SET @counter = @counter + 1;
END;


---------------------------------------------------------------------------------------------------------------------

Correlated subqueries in SQL are subqueries that depend on values from the outer query, which makes them unique because they are evaluated once for each row processed by the outer query. In a correlated subquery, the inner query references a column from the outer query, so it "correlates" with each row processed by the outer query. Let’s break down this concept and look at how it works, with examples.

### Key Characteristics of Correlated Subqueries

1. **Dependency on Outer Query**: The inner (subquery) part of a correlated subquery cannot run independently of the outer query because it refers to columns from the outer query.
2. **Row-by-Row Execution**: The inner query is re-evaluated for each row that the outer query processes, which can sometimes lead to performance considerations, especially with large datasets.
3. **Filtering or Aggregation Context**: Correlated subqueries are often used when you need to compare each row in a table with rows in the same table or another table, especially for tasks like finding matches, filtering, or aggregate values that vary for each row.

### Example Scenario

Let’s use the following tables as an example:

- **Employees**:
  | EmployeeID | EmployeeName | Salary | DepartmentID |
  |------------|--------------|--------|--------------|
  | 1          | John         | 5000   | 1            |
  | 2          | Jane         | 7000   | 2            |
  | 3          | Mike         | 6000   | 1            |
  | 4          | Sara         | 9000   | 2            |
  | 5          | Chris        | 5500   | 1            |

- **Departments**:
  | DepartmentID | DepartmentName |
  |--------------|----------------|
  | 1            | Sales          |
  | 2            | Marketing      |

#### Example 1: Finding Employees with the Highest Salary in Each Department

Suppose you want to list the employees who have the highest salary within their respective departments. To achieve this, a correlated subquery can be used.

```sql
SELECT EmployeeName, Salary, DepartmentID
FROM Employees e1
WHERE Salary = (
    SELECT MAX(Salary)
    FROM Employees e2
    WHERE e2.DepartmentID = e1.DepartmentID
);
```

#### Explanation of the Query

1. **Outer Query**: `SELECT EmployeeName, Salary, DepartmentID FROM Employees e1` – this selects the columns from the `Employees` table. Here, `e1` is an alias for `Employees`, allowing us to differentiate between the outer query and the subquery.
2. **Correlated Subquery**: 
   - `(SELECT MAX(Salary) FROM Employees e2 WHERE e2.DepartmentID = e1.DepartmentID)`: The subquery finds the maximum salary in each department.
   - **Correlation**: `e2.DepartmentID = e1.DepartmentID` – this condition connects each row in the outer query to the rows in the subquery, ensuring the subquery filters data based on the department of each specific employee in the outer query.
3. **Filtering Condition**: The outer query only selects rows where the employee’s salary matches the highest salary found by the subquery.

**Output:**
| EmployeeName | Salary | DepartmentID |
|--------------|--------|--------------|
| Jane         | 7000   | 2            |
| Sara         | 9000   | 2            |

#### How the Correlated Subquery Works Internally

For each employee row in the `Employees` table, SQL Server:
1. **Executes the Subquery**: Finds the maximum salary for the specific `DepartmentID` of the current employee.
2. **Compares Results**: Compares the employee’s salary with the maximum salary for that department.
3. **Returns Rows Matching Condition**: If an employee’s salary equals the department’s maximum, the employee is included in the results.

---

### Another Example: Checking if an Employee Has the Highest Salary in Their Department

If we want to find employees who earn more than the average salary in their department, we can use a correlated subquery to compare each employee’s salary against the department’s average.

```sql
SELECT EmployeeName, Salary, DepartmentID
FROM Employees e1
WHERE Salary > (
    SELECT AVG(Salary)
    FROM Employees e2
    WHERE e2.DepartmentID = e1.DepartmentID
);
```

In this query:
- The subquery calculates the average salary for each department by filtering the `Employees` table based on `DepartmentID` in the outer query.
- For each employee, the subquery calculates the average salary of their department, and the outer query returns only those employees whose salaries are above this average.

**Output:** This would return any employees who earn more than the average salary in their department.

---

### Advantages and Considerations

#### Advantages:
- **Dynamic Filtering**: Correlated subqueries are powerful for cases where data relationships need to be dynamically evaluated row-by-row.
- **Complex Conditions**: They allow complex comparisons that would be difficult to express with simple joins or without the need for additional tables.

#### Considerations:
- **Performance**: Correlated subqueries can be slower, especially with large datasets, because they are executed repeatedly—once per row in the outer query.
- **Optimization**: In some cases, correlated subqueries can be rewritten as joins, which may improve performance by reducing row-by-row execution.

---

### Conclusion

Correlated subqueries are a powerful SQL feature that enables row-level comparisons and filtering, especially for cases where we need to evaluate relationships dynamically. However, due to their potential performance impact, they should be used thoughtfully.

----------------------------------------------------------------------------------------------------------------------------------------------------------

Here's an analysis of each query with comments on any misinterpretations, corrections, and adjustments required for optimal results:

---

### Q1: List Names of Depositors with the Same Branch City as Input Customer’s City

**Current Code:**
```sql
CREATE PROCEDURE sp_list_customer_name
(@CustName VARCHAR(50))
AS
BEGIN
	SELECT d.CNAME, b.BNAME, c.CITY
	FROM DEPOSIT d 
		LEFT JOIN CUSTOMER c ON d.CNAME = c.CNAME
		LEFT JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE
		c.CITY = (SELECT CITY FROM CUSTOMER WHERE CNAME = @CustName)
END

EXECUTE sp_list_customer_name 'NAREN'
```

**Review and Corrections:**
- The **LEFT JOIN** on `CUSTOMER` and `BRANCH` tables is unnecessary; use **INNER JOIN** instead for records that match.
- The code correctly retrieves customers who have deposits in the same city as the input customer’s branch.

**Corrected Code:**
```sql
CREATE PROCEDURE sp_list_customer_name
(@CustName VARCHAR(50))
AS
BEGIN
	SELECT d.CNAME, b.BNAME, c.CITY
	FROM DEPOSIT d
		INNER JOIN CUSTOMER c ON d.CNAME = c.CNAME
		INNER JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE c.CITY = (SELECT CITY FROM CUSTOMER WHERE CNAME = @CustName)
END

EXECUTE sp_list_customer_name 'NAREN';
```

---

### Q2: List All Depositors in JSON Format for Branches Where the Input Customer Has an Account

**Current Code:**
```sql
CREATE PROCEDURE sp_get_depositors
(@CustName VARCHAR(MAX))
AS
BEGIN
	SELECT DISTINCT c.CNAME, d.BNAME, b.CITY 
	FROM CUSTOMER c
		LEFT JOIN BRANCH b ON c.CITY = b.CITY  
		LEFT JOIN DEPOSIT d ON c.CNAME = d.CNAME
	WHERE 
		b.CITY = (SELECT CITY FROM BRANCH WHERE BNAME IN(SELECT BNAME FROM DEPOSIT WHERE CNAME = @CustName))
	FOR JSON PATH
END

EXEC sp_get_depositors 'NAREN';
```

**Review and Corrections:**
- The requirement is to find all depositors who have accounts in the same branches as the input customer. However, the current query is matching **cities** instead of **branches**.
- Use **INNER JOIN** and check directly for branch names.

**Corrected Code:**
```sql
CREATE PROCEDURE sp_get_depositors
(@CustName VARCHAR(50))
AS
BEGIN
	SELECT DISTINCT c.CNAME, d.BNAME, b.CITY 
	FROM CUSTOMER c
		INNER JOIN DEPOSIT d ON c.CNAME = d.CNAME
		INNER JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE d.BNAME IN (SELECT BNAME FROM DEPOSIT WHERE CNAME = @CustName)
	FOR JSON PATH
END

EXEC sp_get_depositors 'NAREN';
```

---

### Q3: Count of Customers in a Given City

**Current Code:**
```sql
CREATE PROCEDURE sp_get_count_by_city
(@CityName VARCHAR(MAX))
AS
BEGIN
	SELECT COUNT(DISTINCT c.CNAME), c.CITY
	FROM CUSTOMER c INNER JOIN BRANCH b ON c.CITY = b.CITY
	WHERE c.CITY = @CityName
	GROUP BY c.CITY
END

EXEC sp_get_count_by_city 'DELHI'
```

**Review:**
- This query will only count customers who live in a city where there is a branch. If this is the intent, it’s correct; otherwise, remove the join to `BRANCH`.

**Final Code:** (No changes needed if the above is intended)

---

### Q4: List All Customers in Given City with Branch City as Mumbai or Delhi in JSON

**Current Code:**
```sql
CREATE PROCEDURE sp_get_customer_conditional
(@CityName VARCHAR(MAX))
AS
BEGIN
	SELECT d.CNAME, c.CITY AS 'Customer City', d.BNAME AS 'Bank Branch', b.CITY
	FROM CUSTOMER c
		INNER JOIN DEPOSIT d ON c.CNAME = d.CNAME
		INNER JOIN BRANCH b ON d.BNAME = b.BNAME
	WHERE b.CITY IN ('MUMBAI','DELHI') AND c.CITY = @CityName
	FOR JSON PATH
END

EXEC sp_get_customer_conditional 'MUMBAI';
```

**Review and Corrections:**
- This query accurately filters customers based on their city and branch city constraints. No changes needed.

---

### Q5: Count of Customers Living in the Same City as Branch Location

**Current Code:**
```sql
CREATE PROCEDURE sp_get_customer_count
AS
BEGIN
	SELECT c.CITY, COUNT(DISTINCT c.CNAME) AS 'Number of Customers'
	FROM CUSTOMER c INNER JOIN BRANCH b ON c.CITY = b.CITY
	GROUP BY c.CITY
END

EXECUTE sp_get_customer_count
```

**Review:**
- This query is correct and fulfills the requirement. No changes needed.

---

### Q6: Insert into `DEPOSIT` Table with JSON Input and Validations

**Current Code:**
```sql
CREATE PROCEDURE sp_json_validation
(@Json_Data VARCHAR(MAX))
AS
BEGIN
	INSERT INTO CUSTOMER
		SELECT * 
		FROM OPENJSON(@Json_Data)
		WITH(
			CNAME VARCHAR(50) '$.CustomerName',
			CITY VARCHAR(50) '$.City'
		);
	
	INSERT INTO DEPOSIT
		SELECT *, GETDATE() AS ADATE 
		FROM OPENJSON(@Json_Data) 
		WITH(
			ACTNO VARCHAR(10) '$.ACTNO',
			CNAME VARCHAR(50) '$.CustomerName',
			BNAME VARCHAR(50) '$.Branch',
			AMOUNT INT '$.amount'
		)
		WHERE AMOUNT > 10;
END
```

**Review and Corrections:**
- Currently, there’s no check for existing customers, which may lead to duplication. Use a condition to insert only new customers.
- The code is correct in terms of **JSON parsing** and **validations** for amount and date.

**Corrected Code:**
```sql
CREATE PROCEDURE sp_json_validation
(@Json_Data VARCHAR(MAX))
AS
BEGIN
	-- Insert into CUSTOMER only if the customer does not already exist
	INSERT INTO CUSTOMER
	SELECT CNAME, CITY
	FROM OPENJSON(@Json_Data)
	WITH(
		CNAME VARCHAR(50) '$.CustomerName',
		CITY VARCHAR(50) '$.City'
	) AS new_data
	WHERE NOT EXISTS (SELECT 1 FROM CUSTOMER WHERE CNAME = new_data.CNAME);

	-- Insert into DEPOSIT with validation on amount and current date
	INSERT INTO DEPOSIT
	SELECT ACTNO, CNAME, BNAME, AMOUNT, GETDATE() AS ADATE
	FROM OPENJSON(@Json_Data) 
	WITH(
		ACTNO VARCHAR(10) '$.ACTNO',
		CNAME VARCHAR(50) '$.CustomerName',
		BNAME VARCHAR(50) '$.Branch',
		AMOUNT INT '$.amount'
	)
	WHERE AMOUNT > 10;
END
```

---

These corrections should help in meeting the exact requirements for each query. Let me know if you have further questions!